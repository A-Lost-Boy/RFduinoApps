/*
   RFduino_Timer2.cpp - Library for RFduino timer.
   Released into the public domain.
 */
#include "Arduino.h"
#include "RFduino_Timer2.h"
#include <assert.h>

#include <functional>   // std::bind


void timer2Interupt(void);

RFduino_Timer2::RFduino_Timer2(void)
{
	_timerExpiresCallback = NULL;
	_timerCallbackUserData = NULL;

	_timerBExpiresCallback = NULL;
	_timerBCallbackUserData = NULL;

	_prescaler = 9;

	// Start 32 MHz crystal oscillator
	NRF_CLOCK->EVENTS_HFCLKSTARTED = 0;
	NRF_CLOCK->TASKS_HFCLKSTART = 1;
	// Wait for the external oscillator to start up
	while (NRF_CLOCK->EVENTS_HFCLKSTARTED == 0) {
		// Do nothing.
	}
	
	//NVIC_EnableIRQ(TIMER2_IRQn);
}

void RFduino_Timer2::interval(unsigned int ms)
{
	//-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	//        Conversion to make cycle calculation easy
	//        Since the cycle is 32 uS hence to generate cycles in mS we need 1000 uS 
	//        1000/32 = 31.25  Hence we need a multiplication factor of 31.25 to the required cycle time to achive it
	//        e.g to get a delay of 10 mS      we would do
	//        NRF_TIMER2->CC[0] = (10*31)+(10/4);
	//-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	//(16M) / (2 ^ 9) = 31250
	float hz = 16000000.0 / pow(2, _prescaler);
	float tn = (1.0 / hz); // uS per tick
	float onems = 1.0 / (tn * 1000);
	int newval = (ms * 31) + (ms / 4);
	
	assert(onems * ms < pow(2, 16));
	_interval = round(onems * ms);
}

void RFduino_Timer2::intervalB(unsigned int ms)
{
	//-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	//        Conversion to make cycle calculation easy
	//        Since the cycle is 32 uS hence to generate cycles in mS we need 1000 uS 
	//        1000/32 = 31.25  Hence we need a multiplication factor of 31.25 to the required cycle time to achive it
	//        e.g to get a delay of 10 mS      we would do
	//        NRF_TIMER2->CC[0] = (10*31)+(10/4);
	//-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	//(16M) / (2 ^ 9) = 31250
	float hz = 16000000.0 / pow(2, _prescaler);
	float tn = (1.0 / hz); // uS per tick
	float onems = 1.0 / (tn * 1000);
	int newval = (ms * 31) + (ms / 4);

	assert(onems * ms < pow(2, 16));
	_intervalB = round(onems * ms);
}

void RFduino_Timer2::prescaler(unsigned int prescaler)
{
	assert(prescaler < 10);
	_prescaler = prescaler;
}

unsigned int RFduino_Timer2::prescaler(void)
{
	return _prescaler;
}

void RFduino_Timer2::start(void)
{
	configureTimer();
	NRF_TIMER2->TASKS_START = 1;
}

void RFduino_Timer2::stop(void)
{
	NRF_TIMER2->TASKS_STOP = 1;
}

void RFduino_Timer2::configureTimer(void)
{
	NRF_TIMER2->TASKS_STOP = 1;	                                   // Stop timer
	NRF_TIMER2->MODE = TIMER_MODE_MODE_Timer;                        // sets the timer to TIME mode (doesn't make sense but OK!)
	NRF_TIMER2->TASKS_CLEAR = 1;                                     // Clear timer
	NRF_TIMER2->BITMODE = TIMER_BITMODE_BITMODE_16Bit;               // with BLE only Timer 1 and Timer 2 and that too only in 16bit mode
	NRF_TIMER2->PRESCALER = _prescaler;	                                   // Prescaler 9 produces 31250 Hz timer frequency => t = 1/f =>  32 uS
	// The figure 31250 Hz is generated by the formula (16M) / (2^n) 
	// where n is the prescaler value 
	// hence (16M)/(2^9)=31250 

	NRF_TIMER2->INTENSET = (TIMER_INTENSET_COMPARE0_Enabled << TIMER_INTENSET_COMPARE0_Pos) | (TIMER_INTENSET_COMPARE1_Enabled << TIMER_INTENSET_COMPARE1_Pos);
	NRF_TIMER2->SHORTS = (TIMER_SHORTS_COMPARE0_CLEAR_Enabled << TIMER_SHORTS_COMPARE0_CLEAR_Pos);                             // Count then Complete mode enabled
	
	NRF_TIMER2->CC[0] = _interval;									//Set value for TIMER2 compare register 0 
	NRF_TIMER2->CC[1] = _intervalB;                                 //Set value for TIMER2 compare register 1 
	attachInterrupt(TIMER2_IRQn, RFduino_Timer2::_interuptCB);																			   // also used in variant.cpp in the RFduino2.2 folder to configure the RTC1 	

}

void RFduino_Timer2::setOnTimerExpires(RFduino_Timer2CallBackType callback, void* user_data)
{
	_timerExpiresCallback = callback;
	_timerCallbackUserData = user_data;
}

void RFduino_Timer2::setOnTimerBExpires(RFduino_Timer2CallBackType callback, void* user_data)
{
	_timerBExpiresCallback = callback;
	_timerBCallbackUserData = user_data;
}

void RFduino_Timer2::_interuptCB(void)
{
	if ((NRF_TIMER2->EVENTS_COMPARE[0] != 0) && ((NRF_TIMER2->INTENSET & TIMER_INTENSET_COMPARE0_Msk) != 0))
	{
		if (timer2->_timerExpiresCallback != NULL)
			timer2->_timerExpiresCallback(timer2->_timerCallbackUserData);
		NRF_TIMER2->EVENTS_COMPARE[0] = 0;
	}
	if ((NRF_TIMER2->EVENTS_COMPARE[1] != 0) && ((NRF_TIMER2->INTENSET & TIMER_INTENSET_COMPARE1_Msk) != 0))
	{
		if (timer2->_timerBExpiresCallback != NULL)
			timer2->_timerBExpiresCallback(timer2->_timerBCallbackUserData);
		NRF_TIMER2->EVENTS_COMPARE[1] = 0;
	}
}

RFduino_Timer2 *timer2 = new RFduino_Timer2();